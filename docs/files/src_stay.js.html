<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\stay.js - @zayesh/stay</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="@zayesh/stay" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.11</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Stay.html">Stay</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Stay.html">Stay</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\stay.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&quot;use strict&quot;;

var EventDispatcher = require(&quot;@zayesh/eventdispatcher&quot;),
 domain = /https?:\/\/((?:[\w\d]+\.)+[\w\d]{2,})/i;

/**
 * Use the native browser url parsing mechanism
 * to retrieve the parts of a url.
 *
 * @method getUrlParts
 * @private
 * @param {string} url - The URL to parse.
 * @return {HTMLAnchorElement} An object containing the url parts.
 */

function getUrlParts(url)
{
 var a = document.createElement(&quot;a&quot;);
 a.href = url;
 return a;
}

/**
 * Checks if the given url is external.
 *
 * @method isExternalUrl
 * @private
 * @param {string} url - The URL to check.
 * @return {boolean} Whether the url is external.
 */

function isExternalUrl(url)
{
 return domain.exec(location.href)[1] !== domain.exec(url)[1];
}

/**
 * The Stay XHR System.
 *
 * Used for requesting page content asynchronously
 * while staying on the same page.
 *
 * Each request can have a hard timeout to avoid endless
 * loading times that are often deemed to fail anyways.
 *
 * @class Stay
 * @constructor
 * @param {Object} options - The options.
 * @param {array} [options.responseFields] - The content container IDs. These have to be the same as the data fields in the server response.
 * @param {string} [options.infix] - The special url pattern infix for the asynchronous content requests.
 * @param {number} [options.timeoutPost] - Hard timeout for POST. 0 means no timeout. Default is 60000 (ms).
 * @param {number} [options.timeoutGet] - Hard timeout for GET. 0 means no timeout. Default is 5000 (ms).
 * @param {boolean} [options.autoUpdate] - Whether Stay should automatically update the page content. Defaults to true.
 */

function Stay(options)
{
 var self = this;

 EventDispatcher.call(this);

 this.responseFields = [&quot;main&quot;, &quot;navigation&quot;, &quot;footer&quot;];
 this.infix = &quot;/json&quot;;
 this.timeoutPost = 60000;
 this.timeoutGet = 5000;
 this.autoUpdate = true;

 if(options !== undefined)
 {
  if(options.responseFields !== undefined) { this.responseFields = options.responseFields; }
  if(options.infix !== undefined) { this.infix = options.infix; }
  if(options.timeoutPost !== undefined) { this.timeoutPost = options.timeoutPost; }
  if(options.timeoutGet !== undefined) { this.timeoutGet = options.timeoutGet; }
  if(options.autoUpdate !== undefined) { this.autoUpdate = options.autoUpdate; }
 }

 this.locked = false;
 this.backForward = false;
 this.absolutePath = null;
 this.containers = [];
 this.intermediateContainer = null;
 this.navigationListeners = [];
 this.eventNavigate = {type: &quot;navigate&quot;};
 this.eventReceive = {type: &quot;receive&quot;, response: null};
 this.eventLoad = {type: &quot;load&quot;};

 if(XMLHttpRequest !== undefined)
 {
  this.xhr = new XMLHttpRequest();
 }
 else
 {
  throw new Error(&quot;XMLHttpRequest functionality not available.&quot;);
 }

 this.xhr.addEventListener(&quot;readystatechange&quot;, function(event) { self._handleResponse(this, event); });
 this.xhr.addEventListener(&quot;timeout&quot;, function()
 {
  var response = {};

  if(self.responseFields.length)
  {
   response.title = &quot;Timeout Error&quot;;
   response[self.responseFields[0]] = Stay.Error.TIMEOUT;
   self.locked = true;
   self.update(response);
  }
 });

 /**
  * Support browser functionality &quot;back&quot; and &quot;forward&quot;.
  * Depends on the boolean variable &quot;locked&quot; in order to
  * determine whether this navigation should be executed.
  * The &quot;backForward&quot; flag tells the system that the next
  * state mustn&#x27;t be pushed.
  */

 window.addEventListener(&quot;popstate&quot;, function(event)
 {
  if(!self.locked &amp;&amp; event.state !== null)
  {
   self.backForward = true;
   self._navigate({href: event.state.url});
  }
 });

 /**
  * This function is bound to all links and forms
  * and executes the desired page navigation on left clicks.
  *
  * @method _switchPage
  * @private
  * @param {Event} event - The event.
  */

 this._switchPage = function(event)
 {
  var preventable = (event.preventDefault !== undefined),
   proceed = false;

  if(event.type === &quot;submit&quot;)
  {
   proceed = true;
  }
  else if(!event.metaKey &amp;&amp; !event.shiftKey &amp;&amp; !event.altKey &amp;&amp; !event.ctrlKey)
  {
   if(event.which !== undefined)
   {
    proceed = event.which === 1;
   }
   else if(event.button !== undefined)
   {
    proceed = event.button === 0;
   }
  }

  if(proceed)
  {
   if(preventable) { event.preventDefault(); }
   if(!self.locked) { self._navigate(this); }
  }

  // Only return false if it was a left click, but the default behaviour couldn&#x27;t be prevented.
  return !(proceed &amp;&amp; !preventable);
 };

 // Indirectly push the initial state.
 this.update({
  title: document.title,
  url: window.location.href
 });

 // Start the system by binding all event handlers.
 this._updateListeners();
}

Stay.prototype = Object.create(EventDispatcher.prototype);
Stay.prototype.constructor = Stay;

/**
 * Adds a response field.
 *
 * @method addResponseField
 * @param {string} field - The field to add.
 */

Stay.prototype.addResponseField = function(field)
{
 if(this.responseFields.indexOf(field) === -1)
 {
  this.responseFields.push(field);
 }
};

/**
 * Removes a response field.
 *
 * @method removeResponseField
 * @param {string} field - The field to remove.
 */

Stay.prototype.removeResponseField = function(field)
{
 var i = this.responseFields.indexOf(field);

 if(i !== -1)
 {
  this.responseFields.splice(i, 1);
 }
};

/**
 * Navigates to the next target uri.
 *
 * @method _navigate
 * @private
 * @param {HTMLElement} firingElement - The element on which the click event occured.
 */

Stay.prototype._navigate = function(firingElement)
{
 var formData, pathname, url, post = false;

 this.locked = true;

 if(firingElement.action)
 {
  // Collect form data if the firing element is a form.
  this.absolutePath = firingElement.action;
  formData = new FormData(firingElement);
  post = true;
 }
 else
 {
  this.absolutePath = firingElement.href;
 }

 pathname = getUrlParts(this.absolutePath).pathname;
 if(pathname.charAt(0) !== &quot;/&quot;) { pathname = &quot;/&quot; + pathname; }

 // Special treatment for the index page.
 url = (pathname === &quot;/&quot;) ?
  this.absolutePath.slice(0, this.absolutePath.length - 1) + this.infix + pathname :
  this.absolutePath.replace(new RegExp(pathname), this.infix + pathname);

 this.eventNavigate.method = post ? &quot;POST&quot; : &quot;GET&quot;;
 this.dispatchEvent(this.eventNavigate);
 this.xhr.open(this.eventNavigate.method, url, true);

 if(post)
 {
  this.xhr.timeout = this.timeoutPost;
  this.xhr.send(formData);
 }
 else
 {
  this.xhr.timeout = this.timeoutGet;
  this.xhr.send();
 }
};

/**
 * Updates the containers with the new data.
 *
 * @method _updateView
 * @private
 * @param {object} response - The response to display. Assumed to contain the data fields specified in &quot;responseFields&quot;.
 */

Stay.prototype._updateView = function(response)
{
 var i, l, c, r, contentChanged = false;

 if(this.intermediateContainer === null)
 {
  this.intermediateContainer = document.createElement(&quot;div&quot;);
 }
 else
 {
  // Clear the intermediate container.
  while(this.intermediateContainer.children.length &gt; 0)
  {
   this.intermediateContainer.removeChild(this.intermediateContainer.children[0]);
  }
 }

 for(i = 0, l = this.responseFields.length; i &lt; l; ++i)
 {
  c = this.containers[this.responseFields[i]];

  if(!c)
  {
   // No reference exists yet. Find the element and remember it.
   c = this.containers[this.responseFields[i]] = document.getElementById(this.responseFields[i]);
  }

  r = response[this.responseFields[i]];

  if(r)
  {
   while(c.children.length &gt; 0)
   {
    c.removeChild(c.children[0]);
   }

   // Let the browser create the DOM elements from the html string.
   this.intermediateContainer.innerHTML = r;

   // Add them one after another.
   while(this.intermediateContainer.children.length &gt; 0)
   {
    c.appendChild(this.intermediateContainer.children[0]);
   }

   contentChanged = true;
  }
 }

 if(contentChanged)
 {
  this._updateListeners();
 }
};

/**
 * Binds event listeners to all links and forms.
 * This method is combined with the cleanup and basically refreshes 
 * the navigation listeners.
 *
 * @method _updateListeners
 * @private
 */

Stay.prototype._updateListeners = function()
{
 var self = this, i, l,
  links = document.getElementsByTagName(&quot;a&quot;),
  forms = document.getElementsByTagName(&quot;form&quot;);

 for(i = 0, l = this.navigationListeners.length; i &lt; l; ++i)
 {
  this.navigationListeners[i][0].removeEventListener(this.navigationListeners[i][1], self._switchPage);
 }

 for(i = 0, l = links.length; i &lt; l; ++i)
 {
  if(!isExternalUrl(links[i].host))
  {
   links[i].addEventListener(&quot;click&quot;, self._switchPage);
   this.navigationListeners.push([links[i], &quot;click&quot;]);
  }
 }

 for(i = 0, l = forms.length; i &lt; l; ++i)
 {
  if(!isExternalUrl(forms[i].action))
  {
   forms[i].addEventListener(&quot;submit&quot;, self._switchPage);
   this.navigationListeners.push([forms[i], &quot;submit&quot;]);
  }
 }
};

/**
 * Updates the view, the navigation listeners and the history state.
 * Also emits an event to signilize that the page has been loaded.
 *
 * The update function needs to be called after each navigation in 
 * order to unlock the system. This happens by default, but that
 * behaviour can be disabled. It is then the responsibility of the
 * programmer to call stay.update() with the response data provided 
 * by the &quot;receive&quot; event.
 *
 * @method update
 * @param {object} response - The response to display.
 */

Stay.prototype.update = function(response)
{
 this._updateView(response);
 document.title = response.title;

 if(response.url)
 {
  this.absolutePath = response.url.replace(this.infix, &quot;&quot;);
 }

 if(!this.backForward)
 {
  history.pushState({url: this.absolutePath}, response.title, this.absolutePath);
 }
 else
 {
  this.backForward = false;
 }

 this.eventReceive.response = null;
 this.dispatchEvent(this.eventLoad);
 this.locked = false;
};

/**
 * This function acts when the xhr object changes its readyState.
 * The response will be a json object or an error page. Anything else will 
 * be treated as a json parse exception.
 *
 * @method _handleResponse
 * @private
 * @param {XMLHttpRequest} xhr - The xhr object that fired the event.
 */

Stay.prototype._handleResponse = function(xhr)
{
 var response = {};

 if(this.responseFields.length === 0)
 {
  response.title = &quot;Setup Error&quot;;
  response[this.responseFields[0]] = Stay.Error.NO_RESPONSE_FIELDS;
 }
 else if(xhr.readyState === 4)
 {
  try
  {
   response = JSON.parse(xhr.responseText);
  }
  catch(e)
  {
   response.title = &quot;Parse Error&quot;;
   response[this.responseFields[0]] = Stay.Error.UNPARSABLE;
   console.log(e);
  }

  response.url = xhr.responseURL;
  this.eventReceive.response = response;
  this.dispatchEvent(this.eventReceive);

  if(this.autoUpdate)
  {
   this.update(response);
  }
 }
};

/**
 * Enumeration of Error Messages.
 *
 * @property Error
 * @private
 * @static
 * @final
 */

Stay.Error = Object.freeze({
 TIMEOUT: &quot;&lt;p&gt;The server didn&#x27;t respond in time. Please try again later!&lt;/p&gt;&quot;,
 UNPARSABLE: &quot;&lt;p&gt;The received content could not be parsed.&lt;/p&gt;&quot;,
 NO_RESPONSE_FIELDS: &quot;&lt;p&gt;No response fields have been specified!&lt;/p&gt;&quot;
});

/**
 * Export as module.
 *
 * @module Stay
 */

module.exports = Stay;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
